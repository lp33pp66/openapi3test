/**
 * Mail Platform API
 * Mail Platform API # Beyond OpenAPI [Reference](reference.html) for API which cannot modeled after OpenAPI. 
 *
 * The version of the OpenAPI document: 0.0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
package org.openapitools.client.api

import org.openapitools.client.model._
import org.json4s._
import scala.reflect.ClassTag

object EnumsSerializers {

  def all: Seq[Serializer[_]] = Seq[Serializer[_]]() :+
    new EnumNameSerializer(AccountEnums.SynchronizeType) :+
    new EnumNameSerializer(AccountDetailEnums.SynchronizeType) :+
    new EnumNameSerializer(AsyncExportJobInfoEnums.State) :+
    new EnumNameSerializer(AsyncImportJobInfoEnums.State) :+
    new EnumNameSerializer(ConnectionParameterEnums.RetrieveType) :+
    new EnumNameSerializer(DomainNetworkListUpdateUpdatesEnums.DataType) :+
    new EnumNameSerializer(FilterNodeEnums.NodeType) :+
    new EnumNameSerializer(GroupEnums.SynchronizeType) :+
    new EnumNameSerializer(GroupWithIdEnums.SynchronizeType) :+
    new EnumNameSerializer(ImportMailFilterEnums.Mode) :+
    new EnumNameSerializer(ImportMatcherConfigEnums.`Type`) :+
    new EnumNameSerializer(IndexErrorsEnums.`Type`) :+
    new EnumNameSerializer(IndexErrorsEnums.Index) :+
    new EnumNameSerializer(IndexErrorsTypeSSSEnums.`Type`) :+
    new EnumNameSerializer(IndexErrorsTypeSSSEnums.Index) :+
    new EnumNameSerializer(InlineObjectEnums.Action) :+
    new EnumNameSerializer(InlineObjectEnums.GroupType) :+
    new EnumNameSerializer(InlineObject10Enums.Sort) :+
    new EnumNameSerializer(MatchDateRangeEnums.`Type`) :+
    new EnumNameSerializer(MatchFlowDirectionEnums.`Type`) :+
    new EnumNameSerializer(MatchGroupEnums.`Type`) :+
    new EnumNameSerializer(MatchSizeRangeEnums.`Type`) :+
    new EnumNameSerializer(MatchStringEnums.`Type`) :+
    new EnumNameSerializer(MessageEnvelopeEnums.Status) :+
    new EnumNameSerializer(MessageEnvelopeShortAttributesMetaProcessNodesEnums.NodeType) :+
    new EnumNameSerializer(PreferenceResolutionEnums.Resolution) :+
    new EnumNameSerializer(ReparseReqSSSEnums.Index) :+
    new EnumNameSerializer(RuleEnums.RetrieveType) :+
    new EnumNameSerializer(RuleListEntryEnums.RetrieveType) :+
    new EnumNameSerializer(ScopedPreferenceEnums.Scope) :+
    new EnumNameSerializer(ScopedPreferenceEnums.Resolution) :+
    new EnumNameSerializer(ScopedPreferenceAllOfEnums.Scope) :+
    new EnumNameSerializer(ScopedPreferenceWithKeyEnums.Scope) :+
    new EnumNameSerializer(ScopedPreferenceWithKeyEnums.Resolution) :+
    new EnumNameSerializer(SmtpConfigEnums.AuthRequired) :+
    new EnumNameSerializer(SmtpNetworkListUpdateUpdatesEnums.DataType) :+
    new EnumNameSerializer(StatusFailureFailureEnums.`Type`) :+
    new EnumNameSerializer(SystemSyncFailuresCleanProcessorEnums.Error) :+
    new EnumNameSerializer(SystemSyncFailuresErrorEnums.Error) :+
    new EnumNameSerializer(SystemSyncFailuresError1Enums.Error) :+
    new EnumNameSerializer(SystemSyncFailuresError2Enums.Error) :+
    new EnumNameSerializer(SystemSyncFailuresInitialProcessorEnums.Error) :+
    new EnumNameSerializer(ThreatBehaviorEnums.Notice) :+
    new EnumNameSerializer(ThreatBehaviorEnums.ReplaceUrl)

  private class EnumNameSerializer[E <: Enumeration: ClassTag](enum: E)
    extends Serializer[E#Value] {
    import JsonDSL._

    val EnumerationClass: Class[E#Value] = classOf[E#Value]

    def deserialize(implicit format: Formats):
    PartialFunction[(TypeInfo, JValue), E#Value] = {
      case (t @ TypeInfo(EnumerationClass, _), json) if isValid(json) =>
        json match {
          case JString(value) =>
            enum.withName(value)
          case value =>
            throw new MappingException(s"Can't convert $value to $EnumerationClass")
        }
    }

    private[this] def isValid(json: JValue) = json match {
      case JString(value) if enum.values.exists(_.toString == value) => true
      case _ => false
    }

    def serialize(implicit format: Formats): PartialFunction[Any, JValue] = {
      case i: E#Value => i.toString
    }
  }

}
